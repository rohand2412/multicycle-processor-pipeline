(1) Discuss the hazards you had to deal with. For each:
 - What type of hazard was it?
 - Show an instruction sequence that exposes it
 - What solutions did you consider?
 - Which one did you pick? Why?

There were five main hazards we had to deal with.
1. Conditional branch outcome differs from branch prediction
- Control hazard
- jz r1, r2 // We predict taking the branch and we don't or vice versa
- We considered two solutions: flushing the pipeline or improving branch prediction
- We picked flushing the pipeline because although improving branch prediction would
  reduce the chance of this hazard it wouldn't make it zero whereas flushing the 
  pipline will work in all cases

2. RAW (read-after-write) regarding registers
- Data hazard
- sub r1, r0, r0 // Writes 0 to r1
  sub r2, r0, r1 // Needs updated value of r1
- We considered two solutions: forwarding the updated reg value or stalling
- We picked forwarding because although stalling would work it wastes a cycle
  and to be honest is overkill for this hazard. It's very simple to implement
  forwarding which mitigates the hazard and doesn't slow down the pipeline.

3. Reading from memory taking two cycles
- Resource hazard
- ld r1, r2 // Load data from memory into r1
  sub r3, r0, r3 // Arbitrary next instruction
- We considered two solutions: stalling or multiple execute stages
- We picked stalling because although multiple execute stages would work
  it adds a whole host of additional complexity and hazards whereas stalling
  very simply freezes the pipeline while the memory is being fetched. This has
  the downside of taking two additional cycles, so we may explore the option
  of multiple execute stages in the future as an optimization.

4. LDP writes to two registers but only one reg write port
- Resource hazard
- ldp r1, r3 // Load data from memory into r1 and r2
  sub r4, r0, r4 // Arbitrary next instruction
- We considered two solutions: stalling or register cache with two write ports
- We picked stalling because although a register cache would work
  it's not trivial to implement as it would need mechanisms for evicting data
  from the cache and knowing who to evict. In contrast, stalling very simply
  freezes the pipeline allowing us to make two uncontested writes to the regs. 
  This has the downside of taking an additional cycle.

5. STP needs three reg values but only two reg read ports
- Resource hazard
- stp r1, r3 // Write r1 and r2 into memory at r3
  sub r4, r5, r6 // Arbitrary next instruction that reads two regs
- We considered two solutions: stalling or register cache with three read ports
- We picked stalling because although register cache would reduce the chance of
  this hazard it wouldn't make it zero whereas stalling very simply freezes the
  pipeline allowing us to make an uncontested read for the third reg. This has
  the downside of taking an additional cycle.

(2) What techniques did you use to improve CPI?
For each:
    - what did you do?
    - what issues did it introduce?
    - how did you address those issues?

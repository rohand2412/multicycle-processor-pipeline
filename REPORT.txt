(1) Discuss the hazards you had to deal with. For each:
 - What type of hazard was it?
 - Show an instruction sequence that exposes it
 - What solutions did you consider?
 - Which one did you pick? Why?

1. Conditional branch outcome differs from branch prediction
- Control hazard
- jz r1, r2 // We predict taking the branch and we don't or vice versa
- We considered two solutions: flushing the pipeline or improving branch prediction
- We picked flushing the pipeline because although improving branch prediction would
  reduce the chance of this hazard it wouldn't make it zero whereas flushing the 
  pipline will work in all cases

2. RAW (read-after-write) regarding registers
- Data hazard
- sub r1, r0, r0 // Writes 0 to r1
  sub r2, r0, r1 // Needs updated value of r1
- We considered two solutions: forwarding the updated reg value or stalling
- We picked forwarding because although stalling would work it wastes a cycle
  and to be honest is overkill for this hazard. It's very simple to implement
  forwarding which mitigates the hazard and doesn't slow down the pipeline.

3. Reading from memory taking two cycles
- Resource hazard
- ld r1, r2 // Load data from memory into r1
  sub r3, r0, r3 // Arbitrary next instruction
- We considered two solutions: stalling or multiple execute stages
- We picked stalling because although multiple execute stages would work
  it adds a whole host of additional complexity and hazards whereas stalling
  very simply freezes the pipeline while the memory is being fetched. This has
  the downside of taking two additional cycles, so we may explore the option
  of multiple execute stages in the future as an optimization.

4. LDP writes to two registers but only one reg write port
- Resource hazard
- ldp r1, r3 // Load data from memory into r1 and r2
  sub r4, r0, r4 // Arbitrary next instruction
- We considered two solutions: stalling or register cache with two write ports
- We picked stalling because although a register cache would work
  it's not trivial to implement as it would need mechanisms for evicting data
  from the cache and knowing who to evict. In contrast, stalling very simply
  freezes the pipeline allowing us to make two uncontested writes to the regs. 
  This has the downside of taking an additional cycle.

5. STP needs three reg values but only two reg read ports
- Resource hazard
- stp r1, r3 // Write r1 and r2 into memory at r3
  sub r4, r5, r6 // Arbitrary next instruction that reads two regs
- We considered two solutions: stalling or register cache with three read ports
- We picked stalling because although register cache would reduce the chance of
  this hazard it wouldn't make it zero whereas stalling very simply freezes the
  pipeline allowing us to make an uncontested read for the third reg. This has
  the downside of taking an additional cycle.

(2) What techniques did you use to improve CPI?
For each:
    - what did you do?
    - what issues did it introduce?
    - how did you address those issues?

1. Branch Prediction
- Created a table that maps a PC to the PC predicted to come next. Initially,
  all PCs are mapped to PC + 1, but everytime a branch is mispredicted the mapping
  from the jump instruction's associated PC is updated with the PC to branch to.
- No issues were introduced. It was very simple to add, instead of incrementing PC
  the PC is updated with the PC provided by the table.
- No issues to address.

2. Removing PC update step for pipeline flush
- Rather than writing new PC to PC and then letting PC put the address in memory,
  we directly put the new PC in memory and update the PC with the predicted branch of
  our new PC from the table. Effectively, simulating the cycle where the PC would update
  itself and write to memory without actually costing us a cycle.
- No issues were introduced. It was just an additional line or two of verilog.
- No issues to address.

3. Precise stalling
- Implemented a mechanism in my pipeline that allows me to freeze my pipeline and
  unfreeze it on demand without losing any cycles. This allowed me to not have to flush
  on every data and resource hazard and rather only burning exactly as many cycles as
  necessary which greatly improved my CPI.
- No issues were introduced as I drew out the mechanism before touching verilog which
  allowed me to vet all oversights before coding.
- No issues to address.
